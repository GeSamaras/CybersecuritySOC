
# Anti-Debugging
![Malware! Oh no!](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/a7df376a927f5fa720f1b37a096184b3.png)  

Debugging is the process of examining software to understand its inner workings and identify potential vulnerabilities or issues. Debugging involves software tools called debuggers that allow analysts to step through the code and monitor its execution.   

  

Here are the commonly used debuggers for malware analysis nowadays:

- x64dbg
- Ollydbg
- Ida Pro
- Ghidra

Anti-Debugging techniques

Malware authors use anti-debugging measures to make it difficult for analysts to use debugging tools to analyze the malware's behaviour.

  

Some of the most common anti-debugging measures include, but are not limited to:

  

|   |   |
|---|---|
|Checking for the presence of debuggers|Malware code looks for processes or files associated with debugging tools or hardware-based techniques, such as detecting hardware breakpoints. For example, a common anti-debugging technique uses the Windows API function `IsDebuggerPresent` to check if a debugger is running. You can see this in action in the [Advanced Dynamic Analysis room](https://tryhackme.com/room/advanceddynamicanalysis).|
|Tampering with debug registers|Malware may try to modify or corrupt debug logs, which debuggers use to control the execution of code. This prevents the debugger from functioning correctly.|
|Using self-modifying code|This is a sophisticated technique where malware modifies itself while running, making it difficult for a debugger to follow the code flow.|

  

In the next task, we will showcase an anti-debugging technique that uses the Windows system API function called SuspendThread.
# Anti-Debugging using Suspend Thread
﻿[Suspend Thread](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread) is a Windows API function that is used to pause the execution of a thread in a running process. This function has legitimate uses but can also be called from within a malware process to suspend any threads attempting to debug or analyze it. What better way to thwart debugging than not making the debugger work at all?  

  

We have created a simple program that does the above technique. You can try and run it to see how it behaves.

  

1. Run the x32dbg tool from the Desktop. Open the `suspend-thread.exe` file from the `C:\Malware\` directory.
2. Press `F9` twice to continue the execution of the malware.  
    
3. Notice that x64dbg will now become unresponsive. You can confirm the suspended process by opening Task Manager.

![Task Manager 1](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/6e78f4aab8de049609c41c5588f70124.png)  

  

_(To completely terminate x64dbg, right click on it and select "End Task")._

  

The code snippet below shows how the malware works under the hood:

  

See code snippet

  

If you don't want to be bothered with reading the source code, here is a short explanation of the steps used by this technique:  

  

1. The malware goes through all threads in the Windows system.
2. For each thread, it calls `EnumWindow` to go through each window displayed on the screen.
3. If the name of the window has the strings `debugger`, `dbg`, or `debug`, then the malware knows that a debugger is running.
4. If a debugger is present, the malware calls, which suspends the threads of the debugger, making it crash.
5. The malware proceeds with its malicious purpose.

As you can see, this method can effectively stop an analyst from continuing with the investigation. Fortunately, we have a way of dealing with this.

Patching

Patching is one of the most critical skills required of an analyst. The Advanced Dynamic Analysis room has already covered this skill, but we'll have a quick review here.

  

In this exercise, we want to patch the function SuspendThread so that our debugger won't get suspended.

  

- Open x32dbg by double-clicking on its icon from the Desktop.
- Press the `F3` key to show the "Open" dialogue window. Look for our sample file called `suspend-thread.exe` in the `C:\Malware\` directory.
- Press the `F9` key once to jump execution to the EntryPoint, as shown below:

![Patching 1](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/71685df3111c0b1789fd7efe893c71c6.png)  

- Right-click anywhere on the main screen, highlight "Search for > Current Module", then select "Intermodular calls".
- On the search field at the bottom, type "SuspendThread". This will filter the list in the main window showing us one entry. Double-click on this entry.

![Patching 2](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/b8346843b287e15dc4403778a3a0a9b0.png)  

- You are now on the part of the code that calls the SuspendThread API. To skip this function, right-click on the Suspendthread line and select Binary > Fill with NOPs. Don't change anything here, and press "OK".

![Patching 3](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/cbebefac61a8e9768eb6bd112efb5822.png)  

- You will see that memory locations `0004011AB` up to `004011B0` are now all set to the `90` hex value or `nop` (No Operation). If execution reaches this instruction, it will do nothing and proceed with the following line. 
- Press `F9` to continue execution, and we'll see that debugging continues at the very end without crashing our debugger. Note that while the console prints out lines that say "Debugger found with PID XXXX! Suspending!", it's not doing anything because we've skipped the function that does the suspending.

![Patching 4](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/2adb65eb552a957b2d52c88edd672cf3.png)  

Now, this is great. However,  if you try debugging again, you'll discover it will start crashing again. This is because our patches are reset and are now gone. To avoid re-applying patches in the future, we can export and import our patches for future use.

  

Exporting and Importing Patches  

  

Stop debugging by pressing `Alt+F2` and go through the patching steps in the previous section again, but do not do the last step. 

  

- Once the patches you want are in place, on the top bar, go to "View > Patch file..." to open the "Patch" dialogue window.
- A list of our patches will appear on the right panel. You can see there are six entries. This refers to the six memory locations that we have set to NOPs.

![Patching 5](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/b7d66b0ffae51d6ba9992e587067cead.png)  

- Click on the "Export" button. On the next dialogue window, click "Yes" to continue. Save this file to a location of your choice.
- Stop the debugger by pressing `Alt+F2`.

Debug the file again. Because debugging has restarted, our previous patches have now been erased. We can restore it by importing the file we made a while ago.

- Go to the patches dialogue window again to "View > Patch file...".
- But this time, press the "Import" button and select the file we saved.

![Patching 6](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/5b3a92ac38ce313efd141f1fddb35572.png)  

- Once imported, close the window and press `F9` again to continue execution. You'll notice that the previous patches are now re-applied.

Exporting and importing patches are very helpful in reverse engineering programs as it allows you to save your work to save the hassle of doing them all over again.

  

In the next task, we'll examine another anti-reverse engineering technique and other ways to circumvent them.

# VM Detection
Virtual Machines (VMs) are software platforms that simulate a computer environment inside another computer system. These are useful in reverse engineering because they provide a cost-effective, controlled, and isolated environment for monitoring and analyzing suspicious software or malware. VMs also allow for the creation of snapshots and checkpoints that can be used to restore the system to a previous state, which helps test different scenarios and maintain a history of the analysis process.

  

When malware identifies that it is running on a VM, it may decide to respond differently; for example, it may change its behaviour by:

- Executing only a minimal subset of its functionality
- Self-destructing by deleting itself or overwriting parts of its code 
- Cause damage to the system by deleting or encrypting files; or
- Not run at all

All of the above behaviours aim to reveal less information, making it harder for the analyst to progress.

  

Detection Techniques  

Malware can employ various techniques to detect and evade analysis in virtual machine environments. Some of them are listed below:

  

  

|   |   |
|---|---|
|Checking running processes|VMs have easily identifiable processes; for example, VMWare runs a process called `vmtools`, while VirtualBox has `vboxservice`. Malware can use the [EnumProcess](https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocesses) Windows API to list all the processes running on the machine and look for the presence of these tools.|
|Checking installed software|Malware can look in the Windows Registry for a list of installed software under the `SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall` Registry key. From here, it can check for installed programs like debuggers, decompilers, forensics tools, etc.|
|Network fingerprinting|Malware can look for specific MAC and network addresses unique to VMs. For example, VMs autogenerate MAC addresses that start with any of the following numbers: `00-05-69`, `00-0c-29`, `00-1c-14` or `00-50-56`. These numbers are unique and are specifically assigned to a VM vendor called the OUI (Organizationally Unique Identifier).|
|Checking machine resources|Malware can look at a machine's resources like RAM and CPU Utilization percentages. For example, a machine with RAM amounting to less than 8GB can indicate a virtual machine, as they are typically not assigned a significant amount.|
|Detecting peripherals|Some malware checks for connected printers because this is rarely configured properly on VMs, sometimes not even configured at all.|
|Checking for domain membership|Corporate networks are a usual target for malware. An easy way to determine this is by checking if the current machine is part of an Active Directory domain. This can quickly be done without the use of API calls by checking the `LoggonServer` and `ComputerName` environment variables.|
|Timing-based attacks|Malware can measure the time it takes to execute specific instructions or access particular machine resources. For example, some instructions can be faster on a physical machine compared to a virtual machine.|

Many techniques mentioned above are not foolproof, so it is not uncommon to see malware use a combination of one or more to ensure a higher chance of correct identification.

Anti-VM Detection

To prevent malware from using some of the techniques above, we can apply several changes to the system that will remove VM-related artefacts making the VM look less like a VM. For example, we can remove or modify the Registry entries that malware checks for installed programs to hide our debuggers, change the MAC addresses, or configure the VM to appear connected to a printer.

But you can see how tedious this becomes. With the myriad of options available to malware, it would be challenging to cover all of them.

Some researchers have made scripts  (See [VMwareCloak](https://github.com/d4rksystem/VMwareCloak) and [VBoxCloak](https://github.com/d4rksystem/VBoxCloak)) to help automate this process. Despite this, even if all the known techniques are addressed, minor architectural checks can still be made by malware, as you will see in the next task.
# VM Detection by Checking the Temp
Here is an example of a VM detection technique that checks the machine's temperature provided by the hardware.

  

`Win32_TemperatureProbe` is a Windows Management Instrumentation (WMI) class that contains real-time temperature readings from the hardware through the SMBIOS (System Management BIOS) data structure. In a virtualized environment, the value returned is `Not Supported`, which is what malware looks for.

  

_**Note:** `Win32_TemperatureProbe` may also return_ _`Not Supported` even on physical machines if the hardware doesn't support this SMBIOS feature. This makes it unreliable but valuable when used with other techniques mentioned in the previous task._

  

We have provided a working program demonstrating this technique in the VM attached to this room. Look for the `vm-detection.exe` file in the `C:\Malware\` directory and execute it. You will see the result immediately.

  

Upon execution, a message window will appear:

  

![VM Detected](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/b6e37b8777df01ca2c1e7c0cafb814dc.png)  

  

As you can see, the malware sensed it was running in a VM. It modified its behaviour by continuing a non-malicious activity to throw off analysts snooping around.

  

Below is the code snippet for this particular program:

  

See code snippet

  

You can try compiling and running this code on your physical machine to see how it changes its behaviour _(No actual malicious execution is in the provided code so it is safe to run)_. The output below shows how the malware behaves when run from a physical machine. The malware receives the correct temperature reading from the WMI class and proceeds with its execution.

  

![Malware did not detect a VM.](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/d2d4144a78e51098656f8bee711c2e07.png)

  

Preventing Temperature Checking

As mentioned in the previous task, architectural checks like checking the temperature can be challenging to prevent. Fortunately for us, there are still ways around this. For example, we've learned in the last task that we can patch a function with `nops` to prevent it from executing. We can do the same thing here, but for the sake of giving you more tools to help you with reverse engineering, we'll be covering two other approaches:

  

- Manipulating memory directly
- Changing the execution flow with EIP

Here are the steps:

  

- Open `x32dbg.exe` by double-clicking on the desktop icon
- Go to File > Open, then look for the `vm-detection.exe` file in the `C:\Malware\` directory.
- Press `F9` to start running the program in the debugger. Debugging will halt at the code marked as the "EntryPoint". 

![Temperature check 1](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/7eb0c75da85be89bb998192fdbe44f2e.png)

- Press `Ctrl+G` on your keyboard to bring up the "Enter expression to follow..." pop-up window. Enter the value `004010E0` and press "OK". This will take you to the memory address. `0x004010E0`.
- Press `F2` to set up a breakpoint at this memory location, then press `F9` once to halt execution here.
- Right now, we are at the memory location `0x004010E0`. The block of instructions from this location up until `0x004010F8` corresponds to this part of our C code snippet: `hr = pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn);`. To help you visualize this, I've added comments on the right side of the screenshot below to highlight the values passed to the function.

![Temperature check 2](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/f1a91972e5981af51a4d668eb5f8ebe8.png)

- As previously discussed, this function will fail because we run the program in a VM. After executing, the function will write the value `0` to the memory location `[ebp-18]` (the one marked with `uReturn` in the screenshot above).
- Press `F8` a few times to step through the code until you reach the memory location `004010FD`. Here, we can see that the value of `[ebp-18]` (or uReturn) is being compared to zero. This corresponds to this part in the C code: `if (uReturn == 0)`.
- Since we want this "if" condition to evaluate to `False`, what we can do is edit the memory location pointed to by `[ebp-18]` so that it will contain the value `1` instead of `0`.
- To do this, right-click on the line that has `[ebp-18]`, click on "Follow in dump", then select `[ebp-18]`.

![Temperature check 3](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/2cc9fdf14ec8de8ec6a062ad5ce3c407.png)  

- You will see at the bottom of the screen, at the "Dump 1" window tab, that our current memory location is `0019FF08`. This memory location contains the value for `[ebp-18]` or uReturn.

![Temperature check 4](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/aa0b40abe6a1292372402b5acac4a6ab.png)  

- Double-click on the rightmost `00` value. This will open up a "Modify Value" window. Enter the value `01` in the expression field and press the "OK" button. The result should look like this:

![Temperature check 5](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/85d660f1c29076c8694f52a1d5c9577d.png)  

- Turn your attention back to the main window (CPU tab) and press `F8` a few times. You'll notice that the code will not exit anymore as it skips the execution from `00401101` to `0040110A`.

What you've done is that you've manipulated the bits of a memory location directly to influence the flow of the program. This method is helpful in many other ways, like for example, you could change the value that will be passed to a function before you execute that function.

However, the program will now crash if you continue running the program. The program was supposed to exit at the previous function, but we've introduced a bug since we intentionally skipped this. Don't worry; this always happens when messing around in the debugger. So for us to continue to investigate, there is one other method we can use that would allow us to jump around and continue.

- Let us say we want to skip everything and jump to this part of the code right here:  `printf("Thermal Zone Temperature: %d\n", vtProp.intVal);`. In the assembly code, this would be the instructions `00401130` to `00401139`, as shown below:

![Temperature check 6](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/29a840731a46e38105443fcdafb9ac64.png)  

The great thing about debuggers is that we can change every value related to the program; we can change the values in the memory locations, the values on the stack, and even the values of the registers. The `EIP` register is the register that holds the memory address that tells the debugger what next instruction to execute next. And yes, this can be edited!

- Continue from the last step. On the "Registers" panel on the right of your screen, look for the one that says `EIP`. Right-click on the value and select "Modify Value".

![Temperature check 7](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/1e0f7ae461f297eb5a48a25b46941518.png)  

- Enter `00401134` as the new value and press OK.
- Now when we press `F8` to step through the code, you'll notice that we'll jump directly to that instruction. Notice how the `EIP` marker now points to the location we wanted.

![Temperature check 8](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/23b17f01fc2ed7906308b2fa782f9742.png)  

- Pressing `F9` again would continue running the program, resulting in the output below:

![Temperature check 9](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/e916e886923e9fc1569760f5924bb0d1.png)  

Good job! With the above steps, you successfully prevented the malware from detecting that it is running on a VM. You can confirm this by also checking the Command Prompt output.

These simple techniques will be helpful in going through the code and influencing the program flow.  

But we can't celebrate just yet, for there are other things malware can do to prevent you from discovering more of its capabilities, like the use of Obfuscation and Packers, which is discussed in the next task.
# Packers
Obfuscation is a technique that aims to intentionally obscure data and code so that it is harder to understand or analyze. 

  

The most common obfuscation techniques used by malware authors include:

- **Using encoding techniques** - This involves encoding data (i.e. command line strings, domain names, etc.) using popular encoding techniques like `XOR` or `Base64`. You may have seen a Base64 encoded strings that look like this `VGhpcyBpcyBhbiBCQVNFNjQgZW5jb2RlZCBzdHJpbmcu==`.
- **Using encryption techniques** - This involves encrypting data such as communications to a command and control server, file formats, and network traffic. The most common types used are symmetric key and public key encryption.
- **Code obfuscation** - This involves various techniques such as manipulating the code to alter its syntax and structure, renaming functions, or splitting code across multiple files or code segments.

There's much to discuss with obfuscation, but we won't delve deep into them in this room. In this task, we want to talk about the wide use of Packers in malware nowadays, a technique that can also be considered to fall under obfuscation.

  

Packers

![Malware Containment](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/718629e08cb56b91b63546abcd971642.png)Packers are tools that compress and encrypt executable files. It compresses the target executable and embeds it within a new executable file that serves as a wrapper or container. This dramatically reduces the size of the file, making it ideal for easy distribution and installation. Also, some packers offer additional features, such as code obfuscation, runtime packing, and anti-debugging techniques. And it is because of these features that made Packers a popular tool for malware authors.

  

There are a lot of Packers available. Each has a unique approach and algorithm for packing. Here is a list of some that were seen used in the wild:

- [Alternate EXE Packer](https://www.alternate-tools.com/pages/c_exepacker.php?lang=ENG)
- [ASPack](http://www.aspack.com/) 
- [ExeStealth](https://unprotect.it/technique/exestealth/)
- [hXOR-Packer](https://github.com/akuafif/hXOR-Packer)
- [Milfuscator](https://github.com/nelfo/Milfuscator)
- [MPress](https://www.autohotkey.com/mpress/mpress_web.htm)
- [PELock](https://www.pelock.com/products/pelock)
- [Themida](https://www.oreans.com/Themida.php)
- [UPX: the Ultimate Packer for eXecutables](https://upx.github.io/)
- [VMProtect](https://vmpsoft.com/)

It is essential to state that not all packed programs are malicious. Packers are also used by legitimate software to protect their programs, like for protecting their intellectual property from theft. For example, the Packer tool "Themida" is widely used to prevent video game cheating.

Because Packers encrypts and obfuscates a program, it would be impossible to know the malware's capabilities without running it. Because of this, we cannot reliably depend on static analysis and signature-based detection techniques to determine its capabilities. The only information we could glean from a malware sample at this state is the Packer tool used. This can still be a good starting point for an investigation, which we will see in the next task.
# Identifying and Unpacking
The first step in dealing with packed malware is identifying the Packer used. Thankfully, there are tools that we can use for this. The most accessible tools are DetectItEasy (DIE) and PEStudio, which are already included in the VM attached to this room. You will also find a packed sample program titled `packed.exe` under the `C:\Malware\` directory that we can use to test these tools on.

  

DetectItEasy is a tool that uses a collection of signatures of known packers to identify the one used on the selected file. 

  

1. Right-click on the `packed.exe` executable file and select "Detect it easy (DIE)".
2. If DetectItEasy can identify the used Packer, it will display its "best guess" under this section.

![Detecting Packers 1](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/6d02e03daa39dd2f16a0c23d90eebbff.png)  

  

1. You can also click on the "Entropy" button on the right side of the screen to open the "Entropy" window.
2. The Entropy window looks and determines how much entropy each section has. And as you can see, it has been determined that "Section 1" is "packed".

![Detecting Packers 2](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/f3346a37c9d378847700cd44e390cbd9.png)  

Entropy measures the level of disorder or uncertainty in a system. Packed malware tends to have high entropy due to the randomness of the packing process.

Another tool is PEStudio which lists information on PE files. This is important because there are specific Packers that will still leave clues.  

  

1. From the Desktop, double-click on the "pestudio" icon.
2. Go through the menus, "File > Open", and open the `packed.exe`.
3. In the list of items on the left panel window, click on "sections (self-modifying)".

![left panel](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/d20925acce3a1b107e34b4fd2d2ee92d.png)  

Usually, the section names of a standard PE file are `.text`, `.data` and `.rsrc`. But in the output above, we can see that this is the section names have been changed. The strings `UPX0`, `UPX1`, and `UPX2` are one of those identifiable pieces of information that Packers like UPX leave behind. Not all Packers change this value, but usually, this is the most accessible first place to look.

Because different Packer tools use various methodologies in packing executables, sometimes tools like DetectItEasy could not identify all types of Packers.

  

Automated Unpacking

Once the Packer for a packed malware is identified, it is possible to use an unpacker to get back the original file. Some are readily available, like in the case of UPX, where you can use the same packing program for unpacking. For other commercial tools like Themida, you may have to rely on unpacker scripts made by 3rd parties.  

  

Here is a short list of scripts that you could use for specific Unpacker tools:

- [Themida](https://github.com/Hendi48/Magicmida)
- [Enigma Protector](https://github.com/ThomasThelen/OllyDbg-Scripts/blob/master/Enigma/Enigma%20Protector%201.90%20-%203.xx%20Alternativ%20Unpacker%20v1.0.txt)
- [Mpress unpacker](https://github.com/avast/retdec/blob/master/src/unpackertool/plugins/mpress/mpress.cpp)

If you chance upon malware packed with an obscure tool or modified to thwart available scripts, things might be more difficult.  

Thankfully, there are services like [unpac.me](https://www.unpac.me/) where you can upload a sample. It will try to identify and unpack the malware for you using custom unpacking and artefact extraction processes. While this service is excellent, it can still fail.

  

Manual Unpacking and Dumping

Ultimately, the best way to unpack malware is to execute it.

  

When a packed malware is executed, the wrapper or container code performs decryption and deobfuscation. Once fully unpacked, the malware can proceed with its true intentions. At this point, the Packer is useless, and we can thoroughly analyze the malware by debugging it while it's in memory using a debugger.

  

We can also dump this unpacked version as a separate executable. 

  

- Open the `packed.exe` using x32dbg.
- Press CTRL+G to open the "Enter expression to follow..." window, input `004172D4` then press "OK".
- You will now be taken to the memory location `004172D4`. This memory location is before the entry point to the legitimate part of the program. 
- Press "F2" to set a breakpoint here, then press "F9" twice to move execution to this location.

![breakpoint 1](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/3bf415b3c23b1f71a6320b8ff439e8fc.png)  

- Finally, press "F7" to jmp to the memory location `00401262`. This location is the starting location of this legitimate program that the Packer goes to once it's fully unpacked. 

![breakpoint 2](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/435c7f14ddc5442500aa15d99d2dfe0e.png)

By now, you may be curious about the memory locations `004172D4` and `00401262`, and their relevance to what we are doing. When this UPX-packed malware is executed and the execution location reaches `004172D4`, it indicates that the legitimate part of the program has already been successfully unpacked and is now copied in memory at `00401262`. As outlined in the next steps, we can now begin dumping from this location.

_**Note:** Other packers have different approaches to unpacking the legitimate part of the program, so the steps above would not work on them.  
_

- To start dumping, go to the top bar menu and click "Plugins > Scylla".
- Scylla is a tool that can dump process memory to disk and fix and rebuild the Import Address Table (IAT). We'll use this to dump the unpacked legitimate part of the program to memory and fix it so it will have the updated memory locations from its DLL imports.
- Once the Scylla plugin window is open, click the "Dump" button.

![Unpacking 1](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/141c6d6bd351e89ffa441e858054553a.png)  

- Save this dumped version to the exact location as the original file.
- If you try to run this dumped version, an error will appear. This is because we have not fixed the import address table yet.

![Unpacking 2](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/d2d9936cf695ce355da8f072cde99766.png)  

- Back in the Scylla plugin window, and click the "IAT Autosearch" button to start. This scans the memory of the process to locate the import address table.
- If a pop-up window asks if you want to use the IAT Search Advanced result, select "No". Then press "OK".

![Unpacking 3](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/560c2e4aee60ce13e565270af77bf7b2.png)  

- At this point, the appropriate values related to the IAT are now computed. We can now click on the "Get Imports" button to update the Imports list section.

![Unpacking 4](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/cfaeea5adbfbebf4b779c240a155810e.png)  

- This list will show all DLLs that are used by the program. The list is short because the program is simple. An actual malware will have a longer list.
- Sometimes, Scylla will find invalid entries; this is marked with the  "X" icon next to it. These are safe to delete because the list already covers every DLL that the program uses. To delete these, go through each invalid entry, right-click, and select "Cut thunk". Once deleted, you should be left with valid entries with check mark icons.
- Click on the "Fix Dump" button, and select the previously generated dump file you created a few steps ago.
- A new file will be created in the same directory as the dumped file with the string "_SCY" appended to its filename. If you execute this, the program will now work correctly.  
    

You can confirm if unpacking was successful by inspecting the generated SCY file using DetectItEasy or PEStudio. Here's the output of DetectItEasy; you'll notice that it does not detect the Packer anymore:

![Unpacking 5](https://tryhackme-images.s3.amazonaws.com/user-uploads/63588b5ef586912c7d03c4f0/room-content/4600cdd205e3dbd31c691b0b5769eafc.png)  

With the malware unpacked, you can now continue investigating the malware. However, don't be fooled into thinking that unpacking packed malware is easy. UPX is the most basic packer tool and the easiest to unpack. Other Packers will be more difficult, primarily if it employs other anti-reverse engineering techniques.